import { describe, it, expect } from 'vitest'
import express from 'express'
import request from 'supertest'
import { AgentAuth } from '../middleware.js'
import { MemoryStore, CryptoNLDriver, hmacSha256Hex, sha256Hex } from '@xagentauth/core'

/**
 * Simulates what an AI agent would do: parse NL instructions and execute byte operations.
 * In production, an LLM parses the natural-language instructions. Here we parse the
 * structured format generated by CryptoNLDriver's PHRASINGS.
 *
 * Supported phrasings (from crypto-nl.ts):
 *
 * XOR:
 *   "XOR each byte with 0x{HEX}"
 *   "Apply exclusive-or with the value {DEC} to every byte"
 *   "Bitwise XOR each octet using the key {DEC}"
 *   "For every byte, flip bits using 0x{HEX} as mask"
 *
 * Reverse:
 *   "Reverse the byte order"
 *   "Flip the sequence end-to-end"
 *   "Mirror the byte array so the last byte becomes first"
 *   "Invert the positional ordering of all bytes"
 *
 * Slice:
 *   "Take bytes from offset {START} to {END}"
 *   "Extract the slice [{START}:{END}] from the data"
 *   "Isolate bytes at positions {START} through {END-1}"
 *
 * Sort:
 *   "Sort all bytes in ascending order"
 *   "Arrange the bytes from smallest to largest value"
 *   "Order the octets numerically, lowest first"
 *
 * Rotate:
 *   "Rotate the bytes left by {N} positions"
 *   "Shift all bytes {N} positions to the left, wrapping around"
 *   "Circular left-shift the array by {N}"
 */
async function agentSolve(payload: {
  instructions: string
  data: string
}): Promise<string> {
  let bytes = new Uint8Array(Buffer.from(payload.data, 'base64'))

  // Parse structured instructions (Step N: operation)
  const lines = payload.instructions.split('\n').filter((l) => l.startsWith('Step'))

  for (const line of lines) {
    // Extract the instruction part after "Step N: "
    const instruction = line.replace(/^Step \d+:\s*/, '')

    if (/xor/i.test(instruction) || /exclusive.or/i.test(instruction) || /flip bits/i.test(instruction)) {
      // XOR operation: extract the key from hex (0x...) or decimal
      const hexMatch = instruction.match(/0x([0-9A-Fa-f]+)/)
      const keyMatch = instruction.match(/(?:value|key)\s+(\d+)/)
      const key = hexMatch
        ? parseInt(hexMatch[1], 16)
        : keyMatch
          ? parseInt(keyMatch[1])
          : 0
      if (key > 0) {
        bytes = bytes.map((b) => b ^ key)
      }
    } else if (
      /reverse/i.test(instruction) ||
      /flip.*end.to.end/i.test(instruction) ||
      /mirror/i.test(instruction) ||
      /invert.*ordering/i.test(instruction)
    ) {
      // Reverse operation
      bytes = bytes.reverse()
    } else if (/sort/i.test(instruction) || /ascending/i.test(instruction) || /smallest.*largest/i.test(instruction) || /lowest first/i.test(instruction)) {
      // Sort operation
      bytes = new Uint8Array([...bytes].sort((a, b) => a - b))
    } else if (/offset.*to\s+(\d+)/i.test(instruction) || /slice\s*\[/i.test(instruction) || /positions?\s+\d+\s+through/i.test(instruction)) {
      // Slice operation — three phrasings:
      //   "Take bytes from offset {start} to {end}"
      //   "Extract the slice [{start}:{end}] from the data"
      //   "Isolate bytes at positions {start} through {end-1}"

      const throughMatch = instruction.match(/positions?\s+(\d+)\s+through\s+(\d+)/)
      if (throughMatch) {
        // "Isolate bytes at positions {start} through {end-1}" — end-1 is given, so we add 1
        const start = parseInt(throughMatch[1])
        const end = parseInt(throughMatch[2]) + 1
        bytes = bytes.slice(start, end)
      } else {
        // "offset {start} to {end}" or "slice [{start}:{end}]"
        const nums = instruction.match(/(\d+)/g)?.map(Number) ?? []
        if (nums.length >= 2) {
          bytes = bytes.slice(nums[0], nums[1])
        }
      }
    } else if (/rotate|shift|circular/i.test(instruction)) {
      // Rotate operation
      const posMatch = instruction.match(/(\d+)\s*position/i) || instruction.match(/by\s+(\d+)/i)
      if (posMatch) {
        const pos = parseInt(posMatch[1]) % bytes.length
        const rotated = new Uint8Array(bytes.length)
        for (let i = 0; i < bytes.length; i++) {
          rotated[i] = bytes[(i + pos) % bytes.length]
        }
        bytes = rotated
      }
    }
  }

  return sha256Hex(bytes)
}

function createApp() {
  const app = express()
  app.use(express.json())

  const auth = new AgentAuth({
    secret: 'e2e-test-secret-that-is-at-least-32-bytes-long!!',
    store: new MemoryStore(),
    drivers: [new CryptoNLDriver()],
    challengeTtlSeconds: 30,
    tokenTtlSeconds: 3600,
    minScore: 0.5,
  })

  app.post('/v1/challenge/init', auth.challenge())
  app.get('/v1/challenge/:id', auth.retrieve())
  app.post('/v1/challenge/:id/solve', auth.verify())
  app.get('/v1/token/verify', auth.tokenVerify())
  app.get('/protected', auth.guard({ minScore: 0.5 }), (_req, res) => {
    res.json({ data: 'agent-only content' })
  })

  return app
}

describe('End-to-end: agent authentication flow', () => {
  const app = createApp()

  it('completes the full challenge → solve → access flow', async () => {
    // Step 1: Agent requests a challenge
    const initRes = await request(app)
      .post('/v1/challenge/init')
      .send({ difficulty: 'easy' })
      .expect(201)

    const { id, session_token } = initRes.body

    // Step 2: Agent retrieves the challenge
    const challengeRes = await request(app)
      .get(`/v1/challenge/${id}`)
      .set('Authorization', `Bearer ${session_token}`)
      .expect(200)

    const { payload } = challengeRes.body

    // Step 3: Agent solves the challenge (parse NL + execute operations)
    const answer = await agentSolve(payload)
    const hmac = await hmacSha256Hex(answer, session_token)

    // Step 4: Agent submits the solution
    const solveRes = await request(app)
      .post(`/v1/challenge/${id}/solve`)
      .send({ answer, hmac, metadata: { model: 'test-agent' } })
      .expect(200)

    expect(solveRes.body.success).toBe(true)
    expect(solveRes.body.token).toBeTruthy()
    expect(solveRes.body.score.reasoning).toBeGreaterThan(0)

    const agentToken = solveRes.body.token

    // Step 5: Agent accesses protected resource
    const protectedRes = await request(app)
      .get('/protected')
      .set('Authorization', `Bearer ${agentToken}`)
      .expect(200)

    expect(protectedRes.body.data).toBe('agent-only content')

    // Step 6: Token can be verified independently
    const verifyRes = await request(app)
      .get('/v1/token/verify')
      .set('Authorization', `Bearer ${agentToken}`)
      .expect(200)

    expect(verifyRes.body.valid).toBe(true)
    expect(verifyRes.body.capabilities.reasoning).toBeGreaterThan(0)

    // Step 7: Challenge cannot be solved again (single-use)
    const replayRes = await request(app)
      .post(`/v1/challenge/${id}/solve`)
      .send({ answer, hmac })
      .expect(200)

    expect(replayRes.body.success).toBe(false)
    expect(replayRes.body.reason).toBe('expired') // deleted from store
  })

  it('rejects unauthenticated access to protected route', async () => {
    await request(app).get('/protected').expect(401)
  })
})
